// --------------------------------------------------------------------------------------------------------------------
// <copyright file="CertHelper.cs" company="OBeautifulCode">
//   Copyright (c) OBeautifulCode 2018. All rights reserved.
// </copyright>
// <auto-generated>
//   Sourced from NuGet package. Will be overwritten with package update except in OBeautifulCode.Security.Recipes source.
// </auto-generated>
// --------------------------------------------------------------------------------------------------------------------

namespace OBeautifulCode.Security.Recipes
{
    using System;
    using System.Collections.Generic;
    using System.Diagnostics.CodeAnalysis;
    using System.Globalization;
    using System.IO;
    using System.Linq;
    using System.Security.Cryptography;
    using System.Security.Cryptography.Pkcs;
    using System.Security.Cryptography.X509Certificates;
    using System.Text;
    using System.Text.RegularExpressions;

    using OBeautifulCode.Security.Recipes.Internal;
    using OBeautifulCode.Type;

    using Org.BouncyCastle.Asn1;
    using Org.BouncyCastle.Asn1.Pkcs;
    using Org.BouncyCastle.Asn1.X509;
    using Org.BouncyCastle.Cms;
    using Org.BouncyCastle.Crypto;
    using Org.BouncyCastle.Crypto.Generators;
    using Org.BouncyCastle.Crypto.Operators;
    using Org.BouncyCastle.Crypto.Parameters;
    using Org.BouncyCastle.OpenSsl;
    using Org.BouncyCastle.Pkcs;
    using Org.BouncyCastle.Security;
    using Org.BouncyCastle.X509;
    using Org.BouncyCastle.X509.Extension;

    using static System.FormattableString;

    using ContentInfo = System.Security.Cryptography.Pkcs.ContentInfo;
    using X509Certificate = Org.BouncyCastle.X509.X509Certificate;
    using X509Extension = Org.BouncyCastle.Asn1.X509.X509Extension;

    /// <summary>
    /// Provides helpers methods for dealing with certificates.
    /// </summary>
    [SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling", Justification = "There are a lot of things you can do with certs!  Should really break this up...")]
#if !OBeautifulCodeSecurityRecipesProject
    [ExcludeFromCodeCoverage]
    [System.CodeDom.Compiler.GeneratedCode("OBeautifulCode.Security.Recipes", "See package version number")]
    internal
#else
    public
#endif
    static class CertHelper
    {
        /// <summary>
        /// Creates an AWS Certificate Manager payload from a PFX file.
        /// </summary>
        /// <param name="input">A byte array of the PFX.</param>
        /// <param name="clearTextPassword">The PFX password in clear-text.</param>
        /// <returns>
        /// A payload that can be used to load certs into the AWS Certificate Manager via the console.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="input"/> is null.</exception>
        /// <exception cref="ArgumentNullException"><paramref name="clearTextPassword"/> is null.</exception>
        /// <exception cref="ArgumentException"><paramref name="clearTextPassword"/> is white space.</exception>
        /// <exception cref="InvalidOperationException">The PFX file does not contain a private key.</exception>
        public static AwsCertificateManagerPayload CreateAwsCertificateManagerPayloadFromPfx(
            byte[] input,
            string clearTextPassword)
        {
            if (input == null)
            {
                throw new ArgumentNullException(nameof(input));
            }

            if (clearTextPassword == null)
            {
                throw new ArgumentNullException(nameof(clearTextPassword));
            }

            if (string.IsNullOrWhiteSpace(clearTextPassword))
            {
                throw new ArgumentException(Invariant($"'{nameof(clearTextPassword)}' is white space"));
            }

            var extractedPfxFile = ExtractCryptographicObjectsFromPfxFile(input, clearTextPassword);

            if (extractedPfxFile.PrivateKey == null)
            {
                throw new InvalidOperationException(Invariant($"{nameof(extractedPfxFile)}.{nameof(ExtractedPfxFile.PrivateKey)} is null"));
            }

            var endUserCertificate = extractedPfxFile.CertificateChain.GetEndUserCertFromCertChain();

            var intermediateCertChain = extractedPfxFile.CertificateChain.GetIntermediateChainFromCertChain();

            var result = new AwsCertificateManagerPayload(endUserCertificate.AsPemEncodedString(), extractedPfxFile.PrivateKey.AsPemEncodedString(), intermediateCertChain.AsPemEncodedString());

            return result;
        }

        /// <summary>
        /// Creates a PFX file.
        /// </summary>
        /// <param name="pemEncodedIntermediateCertificateChainFilePath">Path to a PEM-encoded intermediate certificate chain (often with a 'ca-bundle' extension or file name contains 'bundle').</param>
        /// <param name="pemEncodedCertificateFilePath">Path to PEM-encoded certificate (often with a 'crt' extension).</param>
        /// <param name="clearTextPassword">The password for the PFX file.</param>
        /// <param name="outputPfxFilePath">The path to write the PFX file to.</param>
        /// <param name="overwrite">
        /// Determines whether to overwrite a file that already exist at <paramref name="outputPfxFilePath"/>.
        /// If false and a file exists at that path, the method will throw.
        /// </param>
        /// <param name="pemEncodedPrivateKeyFilePath">Optional path to PEM-encoded private key.  Default is null, no private key specified.</param>
        /// <exception cref="ArgumentNullException"><paramref name="pemEncodedIntermediateCertificateChainFilePath"/> is null.</exception>
        /// <exception cref="ArgumentException"><paramref name="pemEncodedIntermediateCertificateChainFilePath"/> is white space.</exception>
        /// <exception cref="ArgumentNullException"><paramref name="pemEncodedCertificateFilePath"/> is null.</exception>
        /// <exception cref="ArgumentException"><paramref name="pemEncodedCertificateFilePath"/> is white space.</exception>
        /// <exception cref="ArgumentNullException"><paramref name="clearTextPassword"/> is null.</exception>
        /// <exception cref="ArgumentException"><paramref name="clearTextPassword"/> is white space.</exception>
        /// <exception cref="ArgumentNullException"><paramref name="outputPfxFilePath"/> is null.</exception>
        /// <exception cref="ArgumentException"><paramref name="outputPfxFilePath"/> is white space.</exception>
        /// <exception cref="IOException"><paramref name="overwrite"/> is false and there is a file at <paramref name="outputPfxFilePath"/>.</exception>
        [SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling", Justification = "Creating a PFX requires lots of types.")]
        public static void CreatePfxFile(
            string pemEncodedIntermediateCertificateChainFilePath,
            string pemEncodedCertificateFilePath,
            string clearTextPassword,
            string outputPfxFilePath,
            bool overwrite,
            string pemEncodedPrivateKeyFilePath = null)
        {
            if (pemEncodedIntermediateCertificateChainFilePath == null)
            {
                throw new ArgumentNullException(nameof(pemEncodedIntermediateCertificateChainFilePath));
            }

            if (string.IsNullOrWhiteSpace(pemEncodedIntermediateCertificateChainFilePath))
            {
                throw new ArgumentException(Invariant($"'{nameof(pemEncodedIntermediateCertificateChainFilePath)}' is white space"));
            }

            if (pemEncodedCertificateFilePath == null)
            {
                throw new ArgumentNullException(nameof(pemEncodedCertificateFilePath));
            }

            if (string.IsNullOrWhiteSpace(pemEncodedCertificateFilePath))
            {
                throw new ArgumentException(Invariant($"'{nameof(pemEncodedCertificateFilePath)}' is white space"));
            }

            if (clearTextPassword == null)
            {
                throw new ArgumentNullException(nameof(clearTextPassword));
            }

            if (string.IsNullOrWhiteSpace(clearTextPassword))
            {
                throw new ArgumentException(Invariant($"'{nameof(clearTextPassword)}' is white space"));
            }

            if (outputPfxFilePath == null)
            {
                throw new ArgumentNullException(nameof(outputPfxFilePath));
            }

            if (string.IsNullOrWhiteSpace(outputPfxFilePath))
            {
                throw new ArgumentException(Invariant($"'{nameof(outputPfxFilePath)}' is white space"));
            }

            var pemEncodedIntermediateCertificateChain = File.ReadAllText(pemEncodedIntermediateCertificateChainFilePath);

            var intermediateCertificateChain = CertHelper.ReadCertsFromPemEncodedString(pemEncodedIntermediateCertificateChain);

            var pemEncodedCertificate = File.ReadAllText(pemEncodedCertificateFilePath);

            var certificate = ReadCertsFromPemEncodedString(pemEncodedCertificate);

            AsymmetricKeyParameter privateKey = null;

            if (!string.IsNullOrWhiteSpace(pemEncodedPrivateKeyFilePath))
            {
                var pemEncodedPrivateKey = File.ReadAllText(pemEncodedPrivateKeyFilePath);

                privateKey = ReadPrivateKeyFromPemEncodedString(pemEncodedPrivateKey);
            }

            var certChain = certificate.Concat(intermediateCertificateChain.OrderCertChainFromLowestToHighestLevelOfTrust()).ToList();

            CreatePfxFile(certChain, clearTextPassword, outputPfxFilePath, overwrite, privateKey);
        }

        /// <summary>
        /// Creates a PFX file.
        /// </summary>
        /// <param name="certChain">The cert chain.  The order of the certificates is inconsequential.</param>
        /// <param name="clearTextPassword">The password for the PFX file.</param>
        /// <param name="outputPfxFilePath">The path to write the PFX file to.</param>
        /// <param name="overwrite">
        /// Determines whether to overwrite a file that already exist at <paramref name="outputPfxFilePath"/>.
        /// If false and a file exists at that path, the method will throw.
        /// </param>
        /// <param name="privateKey">Optional private key to include in the PFX.</param>
        /// <exception cref="ArgumentNullException"><paramref name="certChain"/> is null.</exception>
        /// <exception cref="ArgumentException"><paramref name="certChain"/> is empty.</exception>
        /// <exception cref="ArgumentException"><paramref name="certChain"/> contains a null element.</exception>
        /// <exception cref="ArgumentNullException"><paramref name="clearTextPassword"/> is null.</exception>
        /// <exception cref="ArgumentException"><paramref name="clearTextPassword"/> is white space.</exception>
        /// <exception cref="ArgumentNullException"><paramref name="outputPfxFilePath"/> is null.</exception>
        /// <exception cref="ArgumentException"><paramref name="outputPfxFilePath"/> is white space.</exception>
        /// <exception cref="ArgumentException"><paramref name="privateKey"/> is not null and not private.</exception>
        /// <exception cref="IOException"><paramref name="overwrite"/> is false and there is a file at <paramref name="outputPfxFilePath"/>.</exception>
        [SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling", Justification = "Creating a PFX requires lots of types.")]
        public static void CreatePfxFile(
            IReadOnlyList<X509Certificate> certChain,
            string clearTextPassword,
            string outputPfxFilePath,
            bool overwrite,
            AsymmetricKeyParameter privateKey = null)
        {
            if (certChain == null)
            {
                throw new ArgumentNullException(nameof(certChain));
            }

            if (!certChain.Any())
            {
                throw new ArgumentException(Invariant($"'{nameof(certChain)}' is an empty enumerable"));
            }

            if (certChain.Any(_ => _ == null))
            {
                throw new ArgumentException(Invariant($"'{nameof(certChain)}' contains an element that is null"));
            }

            if (clearTextPassword == null)
            {
                throw new ArgumentNullException(nameof(clearTextPassword));
            }

            if (string.IsNullOrWhiteSpace(clearTextPassword))
            {
                throw new ArgumentException(Invariant($"'{nameof(clearTextPassword)}' is white space"));
            }

            if (outputPfxFilePath == null)
            {
                throw new ArgumentNullException(nameof(outputPfxFilePath));
            }

            if (string.IsNullOrWhiteSpace(outputPfxFilePath))
            {
                throw new ArgumentException(Invariant($"'{nameof(outputPfxFilePath)}' is white space"));
            }

            if (privateKey != null)
            {
                if (!privateKey.IsPrivate)
                {
                    throw new ArgumentException(Invariant($"'{nameof(privateKey.IsPrivate)}' is false"));
                }
            }

            var mode = overwrite ? FileMode.Create : FileMode.CreateNew;
            using (var fileStream = new FileStream(outputPfxFilePath, mode, FileAccess.Write, FileShare.None))
            {
                CreatePfxFile(certChain, clearTextPassword, fileStream, privateKey);
            }
        }

        /// <summary>
        /// Creates a PFX file.
        /// </summary>
        /// <remarks>
        /// adapted from: <a href="https://boredwookie.net/blog/m/bouncy-castle-create-a-basic-certificate" />.
        /// </remarks>
        /// <param name="certChain">The cert chain.  The order of the certificates is inconsequential.</param>
        /// <param name="clearTextPassword">The password for the PFX file.</param>
        /// <param name="output">The stream to write the PFX file to.</param>
        /// <param name="privateKey">Optional private key to include in the PFX.</param>
        /// <exception cref="ArgumentNullException"><paramref name="certChain"/> is null.</exception>
        /// <exception cref="ArgumentException"><paramref name="certChain"/> is empty.</exception>
        /// <exception cref="ArgumentException"><paramref name="certChain"/> contains a null element.</exception>
        /// <exception cref="ArgumentNullException"><paramref name="clearTextPassword"/> is null.</exception>
        /// <exception cref="ArgumentException"><paramref name="clearTextPassword"/> is white space.</exception>
        /// <exception cref="ArgumentNullException"><paramref name="output"/> is null.</exception>
        /// <exception cref="ArgumentException"><paramref name="output"/> is not writable.</exception>
        /// <exception cref="ArgumentException"><paramref name="privateKey"/> is not null and not private.</exception>
        [SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling", Justification = "Creating a PFX requires lots of types.")]
        public static void CreatePfxFile(
            IReadOnlyList<X509Certificate> certChain,
            string clearTextPassword,
            Stream output,
            AsymmetricKeyParameter privateKey = null)
        {
            if (certChain == null)
            {
                throw new ArgumentNullException(nameof(certChain));
            }

            if (!certChain.Any())
            {
                throw new ArgumentException(Invariant($"'{nameof(certChain)}' is an empty enumerable"));
            }

            if (certChain.Any(_ => _ == null))
            {
                throw new ArgumentException(Invariant($"'{nameof(certChain)}' contains an element that is null"));
            }

            if (clearTextPassword == null)
            {
                throw new ArgumentNullException(nameof(clearTextPassword));
            }

            if (string.IsNullOrWhiteSpace(clearTextPassword))
            {
                throw new ArgumentException(Invariant($"'{nameof(clearTextPassword)}' is white space"));
            }

            if (output == null)
            {
                throw new ArgumentNullException(nameof(output));
            }

            if (!output.CanWrite)
            {
                throw new ArgumentException(Invariant($"'{nameof(output.CanWrite)}' is false"));
            }

            if (privateKey != null)
            {
                if (!privateKey.IsPrivate)
                {
                    throw new ArgumentException(Invariant($"'{nameof(privateKey.IsPrivate)}' is false"));
                }
            }

            certChain = certChain.OrderCertChainFromLowestToHighestLevelOfTrust();

            var store = new Pkcs12StoreBuilder().Build();

            var certEntries = new List<X509CertificateEntry>();

            foreach (var cert in certChain)
            {
                var certEntry = new X509CertificateEntry(cert);

                certEntries.Add(certEntry);

                var certSubjectAttributes = cert.GetX509SubjectAttributes();

                var certStoreKey = certSubjectAttributes[X509SubjectAttributeKind.CommonName];

                store.SetCertificateEntry(certStoreKey, certEntry);
            }

            if (privateKey != null)
            {
                var keyEntry = new AsymmetricKeyEntry(privateKey);

                var firstCert = certChain.First();

                var firstCertSubjectAttributes = firstCert.GetX509SubjectAttributes();

                store.SetKeyEntry(firstCertSubjectAttributes[X509SubjectAttributeKind.CommonName], keyEntry, certEntries.ToArray());
            }

            store.Save(output, clearTextPassword.ToCharArray(), new SecureRandom());
        }

        /// <summary>
        /// Creates an RSA asymmetric cipher key pair.
        /// </summary>
        /// <param name="rsaKeyLength">The length of the rsa key (e.g. 2048 bits).</param>
        /// <returns>
        /// A RSA asymmetric cipher key pair.
        /// </returns>
        public static AsymmetricCipherKeyPair CreateRsaKeyPair(
            int rsaKeyLength = 2048)
        {
            var rsaKeyPairGenerator = new RsaKeyPairGenerator();

            rsaKeyPairGenerator.Init(new KeyGenerationParameters(new SecureRandom(), rsaKeyLength));

            var keyPair = rsaKeyPairGenerator.GenerateKeyPair();

            return keyPair;
        }

        /// <summary>
        /// Creates a certificate signing request for an SSL certificate.
        /// </summary>
        /// <remarks>
        /// Adapted from: <a href="https://gist.github.com/Venomed/5337717aadfb61b09e58" />.
        /// </remarks>
        /// <param name="asymmetricKeyPair">The asymmetric cipher key pair.</param>
        /// <param name="commonName">The common name (e.g. "example.com").</param>
        /// <param name="subjectAlternativeNames">Optional.  The subject alternative names. (e.g. "shopping.example.com", "mail.example.com").</param>
        /// <param name="organizationalUnit">The organizational unit (e.g. "Engineering Dept").</param>
        /// <param name="organization">The organization (e.g. "The Example Company").</param>
        /// <param name="locality">The locality (e.g. "Seattle").</param>
        /// <param name="state">The state (e.g. "Washington").</param>
        /// <param name="country">The country (e.g. "US").</param>
        /// <returns>
        /// The certificate signing request.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="asymmetricKeyPair"/> is null.</exception>
        /// <exception cref="ArgumentNullException"><paramref name="commonName"/> or <paramref name="organizationalUnit"/>or <paramref name="organization"/> or <paramref name="locality"/> or <paramref name="state"/> or <paramref name="country"/> is null.</exception>
        /// <exception cref="ArgumentException"><paramref name="commonName"/> or <paramref name="organizationalUnit"/> or <paramref name="organization"/> or <paramref name="locality"/> or <paramref name="state"/> or <paramref name="country"/> is white space.</exception>
        [SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling", Justification = "There are many types required to construct a CSR.")]
        public static Pkcs10CertificationRequest CreateSslCsr(
            this AsymmetricCipherKeyPair asymmetricKeyPair,
            string commonName,
            IReadOnlyCollection<string> subjectAlternativeNames,
            string organizationalUnit,
            string organization,
            string locality,
            string state,
            string country)
        {
            if (asymmetricKeyPair == null)
            {
                throw new ArgumentNullException(nameof(asymmetricKeyPair));
            }

            if (commonName == null)
            {
                throw new ArgumentNullException(nameof(commonName));
            }

            if (string.IsNullOrWhiteSpace(commonName))
            {
                throw new ArgumentException(Invariant($"'{nameof(commonName)}' is white space"));
            }

            if (organizationalUnit == null)
            {
                throw new ArgumentNullException(nameof(organizationalUnit));
            }

            if (string.IsNullOrWhiteSpace(organizationalUnit))
            {
                throw new ArgumentException(Invariant($"'{nameof(organizationalUnit)}' is white space"));
            }

            if (organization == null)
            {
                throw new ArgumentNullException(nameof(organization));
            }

            if (string.IsNullOrWhiteSpace(organization))
            {
                throw new ArgumentException(Invariant($"'{nameof(organization)}' is white space"));
            }

            if (locality == null)
            {
                throw new ArgumentNullException(nameof(locality));
            }

            if (string.IsNullOrWhiteSpace(locality))
            {
                throw new ArgumentException(Invariant($"'{nameof(locality)}' is white space"));
            }

            if (state == null)
            {
                throw new ArgumentNullException(nameof(state));
            }

            if (string.IsNullOrWhiteSpace(state))
            {
                throw new ArgumentException(Invariant($"'{nameof(state)}' is white space"));
            }

            if (country == null)
            {
                throw new ArgumentNullException(nameof(country));
            }

            if (string.IsNullOrWhiteSpace(country))
            {
                throw new ArgumentException(Invariant($"'{nameof(country)}' is white space"));
            }

            var attributesInOrder = new List<DerObjectValue>
            {
                new DerObjectValue(X509Name.C, country),
                new DerObjectValue(X509Name.ST, state),
                new DerObjectValue(X509Name.L, locality),
                new DerObjectValue(X509Name.O, organization),
                new DerObjectValue(X509Name.OU, organizationalUnit),
                new DerObjectValue(X509Name.CN, commonName),
            };

            var extensions = new Dictionary<DerObjectIdentifier, X509Extension>
            {
                { X509Extensions.BasicConstraints, new X509Extension(true, new DerOctetString(new BasicConstraints(false))) },
                { X509Extensions.KeyUsage, new X509Extension(true, new DerOctetString(new KeyUsage(KeyUsage.DigitalSignature | KeyUsage.KeyEncipherment | KeyUsage.DataEncipherment | KeyUsage.NonRepudiation))) },
                { X509Extensions.ExtendedKeyUsage, new X509Extension(false, new DerOctetString(new ExtendedKeyUsage(KeyPurposeID.IdKPServerAuth, KeyPurposeID.IdKPClientAuth))) },
                { X509Extensions.SubjectKeyIdentifier, new X509Extension(false, new DerOctetString(new SubjectKeyIdentifierStructure(asymmetricKeyPair.Public))) },
            };

            if ((subjectAlternativeNames != null) && subjectAlternativeNames.Any())
            {
                var generalNames = subjectAlternativeNames.Select(_ => new GeneralName(GeneralName.DnsName, _)).ToArray();

                extensions.Add(X509Extensions.SubjectAlternativeName, new X509Extension(false, new DerOctetString(new GeneralNames(generalNames))));
            }

            var result = CreateCsr(asymmetricKeyPair, SignatureAlgorithm.Sha1WithRsaEncryption, attributesInOrder, extensions);

            return result;
        }

        /// <summary>
        /// Decrypts a string that was encrypted as a base-64 string.
        /// </summary>
        /// <param name="base64EncodedEncryptedBytes">The base-64 encoded encrypted bytes.</param>
        /// <param name="certificate">The certificate that was used for encryption.</param>
        /// <param name="encoding">Optional encoding to use.  Default is to use UTF-8.</param>
        /// <returns>
        /// The decrypted string.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="base64EncodedEncryptedBytes"/> is null.</exception>
        /// <exception cref="ArgumentNullException"><paramref name="certificate"/> is null.</exception>
        public static string DecryptStringFromBase64String(
            this string base64EncodedEncryptedBytes,
            X509Certificate2 certificate,
            Encoding encoding = null)
        {
            if (base64EncodedEncryptedBytes == null)
            {
                throw new ArgumentNullException(nameof(base64EncodedEncryptedBytes));
            }

            if (certificate == null)
            {
                throw new ArgumentNullException(nameof(certificate));
            }

            var result = base64EncodedEncryptedBytes.DecryptStringFromBase64String(new[] { certificate }, encoding);

            return result;
        }

        /// <summary>
        /// Decrypts a string that was encrypted as a base-64 string.
        /// </summary>
        /// <param name="base64EncodedEncryptedBytes">The encrypted text to be decrypted.</param>
        /// <param name="certificates">A set of certificates containing the one that was used for encryption.</param>
        /// <param name="encoding">Optional encoding to use.  Default is to use UTF-8.</param>
        /// <returns>
        /// The decrypted string.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="base64EncodedEncryptedBytes"/> is null.</exception>
        /// <exception cref="ArgumentNullException"><paramref name="certificates"/> is null.</exception>
        /// <exception cref="ArgumentException"><paramref name="certificates"/> is empty or contains a null element.</exception>
        public static string DecryptStringFromBase64String(
            this string base64EncodedEncryptedBytes,
            IReadOnlyCollection<X509Certificate2> certificates,
            Encoding encoding = null)
        {
            if (base64EncodedEncryptedBytes == null)
            {
                throw new ArgumentNullException(nameof(base64EncodedEncryptedBytes));
            }

            if (certificates == null)
            {
                throw new ArgumentNullException(nameof(certificates));
            }

            if (!certificates.Any())
            {
                throw new ArgumentException(Invariant($"'{nameof(certificates)}' is an empty enumerable"));
            }

            if (certificates.Any(_ => _ == null))
            {
                throw new ArgumentException(Invariant($"'{nameof(certificates)}' contains an element that is null"));
            }

            encoding = encoding ?? Encoding.UTF8;

            var decryptedBytes = base64EncodedEncryptedBytes.DecryptByteArrayFromBase64String(certificates);

            var result = encoding.GetString(decryptedBytes);

            return result;
        }

        /// <summary>
        /// Decrypts a byte array from a base-64 string.
        /// </summary>
        /// <param name="base64EncodedEncryptedBytes">The base-64 encoded encrypted bytes.</param>
        /// <param name="certificate">The certificate that was used for encryption.</param>
        /// <returns>
        /// The decrypted bytes.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="base64EncodedEncryptedBytes"/> is null.</exception>
        /// <exception cref="ArgumentNullException"><paramref name="certificate"/> is null.</exception>
        public static byte[] DecryptByteArrayFromBase64String(
            this string base64EncodedEncryptedBytes,
            X509Certificate2 certificate)
        {
            if (base64EncodedEncryptedBytes == null)
            {
                throw new ArgumentNullException(nameof(base64EncodedEncryptedBytes));
            }

            if (certificate == null)
            {
                throw new ArgumentNullException(nameof(certificate));
            }

            var result = base64EncodedEncryptedBytes.DecryptByteArrayFromBase64String(new[] { certificate });

            return result;
        }

        /// <summary>
        /// Decrypts a byte array from a base-64 string.
        /// </summary>
        /// <param name="base64EncodedEncryptedBytes">The base-64 encoded encrypted bytes.</param>
        /// <param name="certificates">A set of certificates containing the one that was used for encryption.</param>
        /// <returns>
        /// The decrypted bytes.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="base64EncodedEncryptedBytes"/> is null.</exception>
        /// <exception cref="ArgumentNullException"><paramref name="certificates"/> is null.</exception>
        /// <exception cref="ArgumentException"><paramref name="certificates"/> is empty or contains a null element.</exception>
        public static byte[] DecryptByteArrayFromBase64String(
            this string base64EncodedEncryptedBytes,
            IReadOnlyCollection<X509Certificate2> certificates)
        {
            if (base64EncodedEncryptedBytes == null)
            {
                throw new ArgumentNullException(nameof(base64EncodedEncryptedBytes));
            }

            if (certificates == null)
            {
                throw new ArgumentNullException(nameof(certificates));
            }

            if (!certificates.Any())
            {
                throw new ArgumentException(Invariant($"'{nameof(certificates)}' is an empty enumerable"));
            }

            if (certificates.Any(_ => _ == null))
            {
                throw new ArgumentException(Invariant($"'{nameof(certificates)}' contains an element that is null"));
            }

            var encryptedBytes = Convert.FromBase64String(base64EncodedEncryptedBytes);

            var result = encryptedBytes.Decrypt(certificates);

            return result;
        }

        /// <summary>
        /// Decrypts a byte array.
        /// </summary>
        /// <param name="bytes">The bytes.</param>
        /// <param name="certificate">The certificate that was used for encryption.</param>
        /// <returns>
        /// The decrypted string.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="bytes"/> is null.</exception>
        /// <exception cref="ArgumentNullException"><paramref name="certificate"/> is null.</exception>
        [SuppressMessage("Microsoft.Naming", "CA1720:IdentifiersShouldNotContainTypeNames", MessageId = "bytes", Justification = ObcSuppressBecause.CA1720_IdentifiersShouldNotContainTypeNames_TypeNameAddsClarityToIdentifierAndAlternativesDegradeClarity)]
        public static byte[] Decrypt(
            this byte[] bytes,
            X509Certificate2 certificate)
        {
            if (bytes == null)
            {
                throw new ArgumentNullException(nameof(bytes));
            }

            if (certificate == null)
            {
                throw new ArgumentNullException(nameof(certificate));
            }

            var result = bytes.Decrypt(new[] { certificate });

            return result;
        }

        /// <summary>
        /// Decrypts a byte array.
        /// </summary>
        /// <param name="bytes">The bytes.</param>
        /// <param name="certificates">A set of certificates containing the one that was used for encryption.</param>
        /// <returns>
        /// The decrypted string.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="bytes"/> is null.</exception>
        /// <exception cref="ArgumentNullException"><paramref name="certificates"/> is null.</exception>
        /// <exception cref="ArgumentException"><paramref name="certificates"/> is empty or contains a null element.</exception>
        [SuppressMessage("Microsoft.Naming", "CA1720:IdentifiersShouldNotContainTypeNames", MessageId = "bytes", Justification = ObcSuppressBecause.CA1720_IdentifiersShouldNotContainTypeNames_TypeNameAddsClarityToIdentifierAndAlternativesDegradeClarity)]
        public static byte[] Decrypt(
            this byte[] bytes,
            IReadOnlyCollection<X509Certificate2> certificates)
        {
            if (bytes == null)
            {
                throw new ArgumentNullException(nameof(bytes));
            }

            if (certificates == null)
            {
                throw new ArgumentNullException(nameof(certificates));
            }

            if (!certificates.Any())
            {
                throw new ArgumentException(Invariant($"'{nameof(certificates)}' is an empty enumerable"));
            }

            if (certificates.Any(_ => _ == null))
            {
                throw new ArgumentException(Invariant($"'{nameof(certificates)}' contains an element that is null"));
            }

            var certCollection = new X509Certificate2Collection(certificates.ToArray());

            var envelopedCms = new EnvelopedCms();

            envelopedCms.Decode(bytes);

            envelopedCms.Decrypt(certCollection);

            var result = envelopedCms.ContentInfo.Content;

            return result;
        }

        /// <summary>
        /// Encrypts the specified string to a base-64 string.
        /// </summary>
        /// <param name="plaintext">The plaintext to be encrypted.</param>
        /// <param name="certificate">The certificate to use for encryption.</param>
        /// <param name="encoding">Optional encoding to use.  Default is to use UTF-8.</param>
        /// <returns>
        /// The specified string encrypted as a base-64 string.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="plaintext"/> is null.</exception>
        /// <exception cref="ArgumentNullException"><paramref name="certificate"/> is null.</exception>
        public static string EncryptToBase64String(
            this string plaintext,
            X509Certificate2 certificate,
            Encoding encoding = null)
        {
            if (plaintext == null)
            {
                throw new ArgumentNullException(nameof(plaintext));
            }

            if (certificate == null)
            {
                throw new ArgumentNullException(nameof(certificate));
            }

            encoding = encoding ?? Encoding.UTF8;

            var bytes = encoding.GetBytes(plaintext);

            var result = bytes.EncryptToBase64String(certificate);

            return result;
        }

        /// <summary>
        /// Encrypts the specified byte array to a base-64 string.
        /// </summary>
        /// <param name="bytes">The bytes to be encrypted.</param>
        /// <param name="certificate">The certificate to use for encryption.</param>
        /// <returns>
        /// The specified byte array encrypted as a base-64 string.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="bytes"/> is null.</exception>
        /// <exception cref="ArgumentNullException"><paramref name="certificate"/> is null.</exception>
        [SuppressMessage("Microsoft.Naming", "CA1720:IdentifiersShouldNotContainTypeNames", MessageId = "bytes", Justification = ObcSuppressBecause.CA1720_IdentifiersShouldNotContainTypeNames_TypeNameAddsClarityToIdentifierAndAlternativesDegradeClarity)]
        public static string EncryptToBase64String(
            this byte[] bytes,
            X509Certificate2 certificate)
        {
            if (bytes == null)
            {
                throw new ArgumentNullException(nameof(bytes));
            }

            if (certificate == null)
            {
                throw new ArgumentNullException(nameof(certificate));
            }

            var encryptedBytes = bytes.Encrypt(certificate);

            var result = Convert.ToBase64String(encryptedBytes);

            return result;
        }

        /// <summary>
        /// Encrypts the specified bytes.
        /// </summary>
        /// <param name="bytes">The bytes to encrypt.</param>
        /// <param name="certificate">The certificate to use for encryption.</param>
        /// <returns>
        /// The encrypted bytes.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="bytes"/> is null.</exception>
        /// <exception cref="ArgumentNullException"><paramref name="certificate"/> is null.</exception>
        [SuppressMessage("Microsoft.Naming", "CA1720:IdentifiersShouldNotContainTypeNames", MessageId = "bytes", Justification = ObcSuppressBecause.CA1720_IdentifiersShouldNotContainTypeNames_TypeNameAddsClarityToIdentifierAndAlternativesDegradeClarity)]
        public static byte[] Encrypt(
            this byte[] bytes,
            X509Certificate2 certificate)
        {
            if (bytes == null)
            {
                throw new ArgumentNullException(nameof(bytes));
            }

            if (certificate == null)
            {
                throw new ArgumentNullException(nameof(certificate));
            }

            var contentInfo = new ContentInfo(bytes);

            var envelopedCms = new EnvelopedCms(contentInfo);

            var cmsRecipient = new CmsRecipient(certificate);

            envelopedCms.Encrypt(cmsRecipient);

            var result = envelopedCms.Encode();

            return result;
        }

        /// <summary>
        /// Gets a certificate collection from the certificate store.
        /// </summary>
        /// <param name="storeLocation">The store location.</param>
        /// <param name="storeName">The name of the store.</param>
        /// <returns>
        /// A certificate collection.
        /// </returns>
        public static X509Certificate2Collection GetCertificateCollectionFromStore(
            StoreLocation storeLocation,
            StoreName storeName)
        {
            using (var store = new X509Store(storeName, storeLocation))
            {
                store.Open(OpenFlags.ReadOnly);

                var result = store.Certificates;

                return result;
            }
        }

        /// <summary>
        /// Gets certificates from the certificate store.
        /// </summary>
        /// <param name="storeLocation">The store location.</param>
        /// <param name="storeName">The name of the store.</param>
        /// <returns>
        /// Certificates from the certificate store.
        /// </returns>
        public static IReadOnlyCollection<X509Certificate2> GetCertificatesFromStore(
            StoreLocation storeLocation,
            StoreName storeName)
        {
            var certificateCollection = GetCertificateCollectionFromStore(storeLocation, storeName);

            var result = certificateCollection.OfType<X509Certificate2>().ToList();

            return result;
        }

        /// <summary>
        /// Finds a certificate in the specified store.
        /// </summary>
        /// <param name="storeLocation">Store location (eg. LocalMachine).</param>
        /// <param name="storeName">Store name to search for certificate (eg: My).</param>
        /// <param name="thumbprint">Thumbprint of the certificate to search for.</param>
        /// <param name="shouldThrowIfNotFound">A value indicating whether to throw an exception if the certificate is not found.</param>
        /// <param name="shouldThrowIfCertificateIsInvalid">A value indicating whether to throw an exception if the certificate is not valid.</param>
        /// <returns>
        /// The certificate if found, otherwise null.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="thumbprint"/> is null.</exception>
        /// <exception cref="ArgumentException"><paramref name="thumbprint"/> is white space.</exception>
        /// <exception cref="InvalidOperationException">The certificate was not found and <paramref name="shouldThrowIfNotFound"/> is true.</exception>
        /// <exception cref="InvalidOperationException">Found multiple certificates.</exception>
        /// <exception cref="InvalidOperationException">The certificate is invalid and <paramref name="shouldThrowIfCertificateIsInvalid"/> is true.</exception>
        public static X509Certificate2 GetCertificateFromStore(
            this StoreLocation storeLocation,
            StoreName storeName,
            string thumbprint,
            bool shouldThrowIfNotFound,
            bool shouldThrowIfCertificateIsInvalid)
        {
            var certificateCollection = GetCertificateCollectionFromStore(storeLocation, storeName);

            var potentiallyInvalidCerts = certificateCollection.Find(X509FindType.FindByThumbprint, thumbprint, false);

            if (potentiallyInvalidCerts.Count == 0)
            {
                if (shouldThrowIfNotFound)
                {
                    throw new InvalidOperationException(Invariant($"Certificate was not found.  Specified thumbprint: {thumbprint}"));
                }
                else
                {
                    return null;
                }
            }

            if (potentiallyInvalidCerts.Count != 1)
            {
                throw new InvalidOperationException(Invariant($"Expected a single certificate but found {potentiallyInvalidCerts.Count} certificates.  Specified thumbprint: {thumbprint}"));
            }

            if (shouldThrowIfCertificateIsInvalid)
            {
                var validCerts = certificateCollection.Find(X509FindType.FindByThumbprint, thumbprint, true);

                if (validCerts.Count != 1)
                {
                    throw new InvalidOperationException(Invariant($"The certificate is invalid and {nameof(shouldThrowIfCertificateIsInvalid)} is true.  Specified thumbprint: {thumbprint}"));
                }
            }

            var result = potentiallyInvalidCerts[0];

            return result;
        }

        /// <summary>
        /// Extracts the cryptographic objects contained in a PFX file.
        /// </summary>
        /// <param name="input">A byte array of the PFX.</param>
        /// <param name="clearTextPassword">The PFX password in clear-text.</param>
        /// <returns>
        /// The cryptographic objects contained in the specified PFX file.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="input"/> is null.</exception>
        /// <exception cref="ArgumentNullException"><paramref name="clearTextPassword"/> is null.</exception>
        /// <exception cref="ArgumentException"><paramref name="clearTextPassword"/> is white space.</exception>
        public static ExtractedPfxFile ExtractCryptographicObjectsFromPfxFile(
            byte[] input,
            string clearTextPassword)
        {
            if (input == null)
            {
                throw new ArgumentNullException(nameof(input));
            }

            if (clearTextPassword == null)
            {
                throw new ArgumentNullException(nameof(clearTextPassword));
            }

            if (string.IsNullOrWhiteSpace(clearTextPassword))
            {
                throw new ArgumentException(Invariant($"'{nameof(clearTextPassword)}' is white space"));
            }

            using (var inputStream = new MemoryStream(input))
            {
                var result = ExtractCryptographicObjectsFromPfxFile(inputStream, clearTextPassword);
                return result;
            }
        }

        /// <summary>
        /// Extracts the cryptographic objects contained in a PFX file.
        /// </summary>
        /// <param name="input">A stream with the PFX.</param>
        /// <param name="clearTextPassword">The PFX password in clear-text.</param>
        /// <returns>
        /// The cryptographic objects contained in the specified PFX file.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="input"/> is null.</exception>
        /// <exception cref="ArgumentException"><paramref name="input"/> is not readable.</exception>
        /// <exception cref="ArgumentNullException"><paramref name="clearTextPassword"/> is null.</exception>
        /// <exception cref="ArgumentException"><paramref name="clearTextPassword"/> is white space.</exception>
        public static ExtractedPfxFile ExtractCryptographicObjectsFromPfxFile(
            Stream input,
            string clearTextPassword)
        {
            if (input == null)
            {
                throw new ArgumentNullException(nameof(input));
            }

            if (!input.CanRead)
            {
                throw new ArgumentException(Invariant($"'{nameof(input.CanRead)}' is false"));
            }

            if (clearTextPassword == null)
            {
                throw new ArgumentNullException(nameof(clearTextPassword));
            }

            if (string.IsNullOrWhiteSpace(clearTextPassword))
            {
                throw new ArgumentException(Invariant($"'{nameof(clearTextPassword)}' is white space"));
            }

            var store = new Pkcs12Store(input, clearTextPassword.ToCharArray());
            
            var aliases = store.Aliases;

            var certificateChain = new List<X509Certificate>();
            
            foreach (var alias in aliases)
            {
                var certEntry = store.GetCertificate(alias.ToString());

                certificateChain.Add(certEntry.Certificate);
            }

            var endUserCertificate = certificateChain.GetEndUserCertFromCertChain();

            var subjectAttributes = endUserCertificate.GetX509SubjectAttributes();

            var storeKey = store.GetKey(subjectAttributes[X509SubjectAttributeKind.CommonName]);

            var privateKey = storeKey.Key;

            var result = new ExtractedPfxFile(certificateChain, privateKey);

            return result;
        }

        /// <summary>
        /// Finds a certificate in the specified store.
        /// </summary>
        /// <param name="storeLocation">Store location (eg. LocalMachine).</param>
        /// <param name="storeName">Store name to search for certificate (eg: My).</param>
        /// <param name="thumbprint">Thumbprint of the certificate to search for.</param>
        /// <param name="unsecuredPassword">Password to use for PFX file.</param>
        /// <param name="filePath">PFX file path to write to.</param>
        /// <param name="shouldThrowIfCertificateIsInvalid">A value indicating whether to throw an exception if the certificate is not valid.</param>
        /// <param name="shouldThrowIfPrivateKeyIsMissing">A value indicating whether to throw an exception if the certificate does not contain a private key.</param>
        /// <exception cref="ArgumentNullException"><paramref name="thumbprint"/> is null.</exception>
        /// <exception cref="ArgumentException"><paramref name="thumbprint"/> is white space.</exception>
        /// <exception cref="ArgumentNullException"><paramref name="unsecuredPassword"/> is null.</exception>
        /// <exception cref="ArgumentException"><paramref name="unsecuredPassword"/> is white space.</exception>
        /// <exception cref="InvalidOperationException">The certificate was not found.</exception>
        /// <exception cref="InvalidOperationException">Found multiple certificates.</exception>
        /// <exception cref="InvalidOperationException">The certificate is invalid and <paramref name="shouldThrowIfCertificateIsInvalid"/> is true.</exception>
        /// <exception cref="InvalidOperationException">The certificate does not contain the private key and <paramref name="shouldThrowIfPrivateKeyIsMissing"/> is true.</exception>
        public static void ExportPfxFromCertificateStoreToFile(
            this StoreLocation storeLocation,
            StoreName storeName,
            string thumbprint,
            string unsecuredPassword,
            string filePath,
            bool shouldThrowIfCertificateIsInvalid,
            bool shouldThrowIfPrivateKeyIsMissing)
        {
            if (thumbprint == null)
            {
                throw new ArgumentNullException(nameof(thumbprint));
            }

            if (string.IsNullOrWhiteSpace(thumbprint))
            {
                throw new ArgumentException(Invariant($"'{nameof(thumbprint)}' is white space"));
            }

            if (unsecuredPassword == null)
            {
                throw new ArgumentNullException(nameof(unsecuredPassword));
            }

            if (string.IsNullOrWhiteSpace(unsecuredPassword))
            {
                throw new ArgumentException(Invariant($"'{nameof(unsecuredPassword)}' is white space"));
            }

            if (filePath == null)
            {
                throw new ArgumentNullException(nameof(filePath));
            }

            if (string.IsNullOrWhiteSpace(filePath))
            {
                throw new ArgumentException(Invariant($"'{nameof(filePath)}' is white space"));
            }

            var cert = GetCertificateFromStore(storeLocation, storeName, thumbprint, true, shouldThrowIfCertificateIsInvalid);

            if (shouldThrowIfPrivateKeyIsMissing && (!cert.HasPrivateKey))
            {
                throw new InvalidOperationException(Invariant($"The certificate does not contain the private key and {nameof(shouldThrowIfPrivateKeyIsMissing)} is true.  Specified thumbprint: {thumbprint}"));
            }

            AsymmetricKeyParameter privateKey = null;

            if (cert.HasPrivateKey)
            {
                try
                {
                    var rsa = (RSACryptoServiceProvider)cert.PrivateKey;

                    var keyPair = DotNetUtilities.GetRsaKeyPair(rsa);

                    privateKey = keyPair.Private;
                }
                catch (CryptographicException)
                {
                    // 1. we have seen cases where cert.PrivateKey throws on a cert that was NOT created using CertHelper
                    // 2. we have seen cases where .GetRsaKeyPair(rsa) throws on a cert that was installed via a PFX file created by CertHelper (NOT marking the private key as exportable)
                }
            }

            var parser = new X509CertificateParser();

            var bouncyCerts = new List<X509Certificate>();

            using (var chain = new X509Chain())
            {
                chain.Build(cert);

                foreach (var chainElement in chain.ChainElements)
                {
                    var bouncyCert = parser.ReadCertificate(chainElement.Certificate.Export(X509ContentType.Cert));

                    bouncyCerts.Add(bouncyCert);
                }
            }

            CreatePfxFile(bouncyCerts, unsecuredPassword, filePath, true, privateKey);
        }

        /// <summary>
        /// Gets the end-user certificate in a certificate chain.
        /// </summary>
        /// <param name="certChain">The certificate chain.</param>
        /// <returns>
        /// The end-user certificate in the specified certificate chain.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="certChain"/> is null.</exception>
        /// <exception cref="ArgumentException"><paramref name="certChain"/> is empty.</exception>
        /// <exception cref="ArgumentException"><paramref name="certChain"/> contains a null element.</exception>
        /// <exception cref="ArgumentException"><paramref name="certChain"/> is malformed.</exception>
        public static X509Certificate GetEndUserCertFromCertChain(
            this IReadOnlyCollection<X509Certificate> certChain)
        {
            if (certChain == null)
            {
                throw new ArgumentNullException(nameof(certChain));
            }

            if (!certChain.Any())
            {
                throw new ArgumentException(Invariant($"'{nameof(certChain)}' is an empty enumerable"));
            }

            if (certChain.Any(_ => _ == null))
            {
                throw new ArgumentException(Invariant($"'{nameof(certChain)}' contains an element that is null"));
            }

            var result = certChain.OrderCertChainFromHighestToLowestLevelOfTrust().Last();
            return result;
        }

        /// <summary>
        /// Gets the intermediate certificate chain from a certificate chain that contains
        /// the end-user certificate.
        /// </summary>
        /// <param name="certChain">The certificate chain.</param>
        /// <returns>
        /// The intermediate cert chain.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="certChain"/> is null.</exception>
        /// <exception cref="ArgumentException"><paramref name="certChain"/> is empty.</exception>
        /// <exception cref="ArgumentException"><paramref name="certChain"/> contains a null element.</exception>
        /// <exception cref="ArgumentException"><paramref name="certChain"/> is malformed.</exception>
        public static IReadOnlyList<X509Certificate> GetIntermediateChainFromCertChain(
            this IReadOnlyCollection<X509Certificate> certChain)
        {
            if (certChain == null)
            {
                throw new ArgumentNullException(nameof(certChain));
            }

            if (!certChain.Any())
            {
                throw new ArgumentException(Invariant($"'{nameof(certChain)}' is an empty enumerable"));
            }

            if (certChain.Any(_ => _ == null))
            {
                throw new ArgumentException(Invariant($"'{nameof(certChain)}' contains an element that is null"));
            }

            var result = certChain.OrderCertChainFromHighestToLowestLevelOfTrust().Take(certChain.Count - 1).ToList();

            return result;
        }

        /// <summary>
        /// Gets the thumbprint of an X509 certificate.
        /// </summary>
        /// <param name="cert">The certificate.</param>
        /// <returns>
        /// The thumbprint of the specified X509 certificate.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="cert"/> is null.</exception>
        [SuppressMessage("Microsoft.Globalization", "CA1308:NormalizeStringsToUppercase", Justification = "We specifically want lower-case here.")]
        public static string GetThumbprint(
            this X509Certificate cert)
        {
            if (cert == null)
            {
                throw new ArgumentNullException(nameof(cert));
            }

            using (var shaProvider = new SHA1CryptoServiceProvider())
            {
                var hash = shaProvider.ComputeHash(cert.GetEncoded());

                var result = BitConverter.ToString(hash).Replace("-", " ").ToLowerInvariant();

                return result;
            }
        }

        /// <summary>
        /// Gets the range of time over which a certificate is valid.
        /// </summary>
        /// <param name="cert">The certificate.</param>
        /// <returns>
        /// The range of time over which the specified certificate is valid.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="cert"/> is null.</exception>
        public static UtcDateTimeRangeInclusive GetValidityPeriod(
            this X509Certificate cert)
        {
            if (cert == null)
            {
                throw new ArgumentNullException(nameof(cert));
            }

            var result = new UtcDateTimeRangeInclusive(cert.NotBefore, cert.NotAfter);

            return result;
        }

        /// <summary>
        /// Gets the X509 field values from a certificate.
        /// </summary>
        /// <param name="cert">The certificate.</param>
        /// <returns>
        /// The X509 field values indexed by the kind of field.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="cert"/> is null.</exception>
        public static IReadOnlyDictionary<X509FieldKind, string> GetX509Fields(
            this X509Certificate cert)
        {
            if (cert == null)
            {
                throw new ArgumentNullException(nameof(cert));
            }

            var result = new Dictionary<X509FieldKind, string>
            {
                { X509FieldKind.IssuerName, cert.IssuerDN?.ToString() },
                { X509FieldKind.NotAfter, cert.NotAfter.ToString("yyyy-MM-ddTHH:mm:ssZ", CultureInfo.InvariantCulture) },
                { X509FieldKind.NotBefore, cert.NotBefore.ToString("yyyy-MM-ddTHH:mm:ssZ", CultureInfo.InvariantCulture) },
                { X509FieldKind.SerialNumber, cert.SerialNumber?.ToString() },
                { X509FieldKind.SignatureAlgorithmName, cert.SigAlgName },
                { X509FieldKind.SubjectName, cert.SubjectDN?.ToString() },
                { X509FieldKind.Version, cert.Version.ToString(CultureInfo.InvariantCulture) },
            };
            return result;
        }

        /// <summary>
        /// Gets the X509 subject attribute values from a certificate signing request.
        /// </summary>
        /// <param name="csr">The certificate signing request.</param>
        /// <returns>
        /// The X509 subject attribute values indexed by the kind of subject attribute.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="csr"/> is null.</exception>
        [SuppressMessage("Microsoft.Design", "CA1011:ConsiderPassingBaseTypesAsParameters", Justification = "Specifically supporting this kind of CSR.")]
        public static IReadOnlyDictionary<X509SubjectAttributeKind, string> GetX509SubjectAttributes(
            this Pkcs10CertificationRequest csr)
        {
            if (csr == null)
            {
                throw new ArgumentNullException(nameof(csr));
            }

            var subject = csr.GetCertificationRequestInfo().Subject;

            var result = subject.GetX509SubjectAttributes();

            return result;
        }

        /// <summary>
        /// Gets the X509 subject attribute values from a certificate.
        /// </summary>
        /// <param name="cert">The certificate.</param>
        /// <returns>
        /// The X509 subject attribute values indexed by the kind of subject attribute.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="cert"/> is null.</exception>
        public static IReadOnlyDictionary<X509SubjectAttributeKind, string> GetX509SubjectAttributes(
            this X509Certificate cert)
        {
            if (cert == null)
            {
                throw new ArgumentNullException(nameof(cert));
            }

            var subject = cert.SubjectDN;

            var result = subject.GetX509SubjectAttributes();

            return result;
        }

        /// <summary>
        /// Gets the X509 subject attribute values from a subject.
        /// </summary>
        /// <param name="subject">The subject.</param>
        /// <returns>
        /// The X509 subject attribute values indexed by the kind of subject attribute.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="subject"/> is null.</exception>
        public static IReadOnlyDictionary<X509SubjectAttributeKind, string> GetX509SubjectAttributes(
            this X509Name subject)
        {
            if (subject == null)
            {
                throw new ArgumentNullException(nameof(subject));
            }

            var objectIds = subject.GetOidList();
            var values = subject.GetValueList();

            var result = new Dictionary<X509SubjectAttributeKind, string>();

            for (int x = 0; x < objectIds.Count; x++)
            {
                if ((objectIds[x] is DerObjectIdentifier derId) && (values[x] is string value))
                {
                    if (derId.Id == X509Name.C.Id)
                    {
                        result.Add(X509SubjectAttributeKind.Country, value);
                    }
                    else if (derId.Id == X509Name.O.Id)
                    {
                        result.Add(X509SubjectAttributeKind.Organization, value);
                    }
                    else if (derId.Id == X509Name.OU.Id)
                    {
                        result.Add(X509SubjectAttributeKind.OrganizationalUnit, value);
                    }
                    else if (derId.Id == X509Name.T.Id)
                    {
                        result.Add(X509SubjectAttributeKind.Title, value);
                    }
                    else if (derId.Id == X509Name.CN.Id)
                    {
                        result.Add(X509SubjectAttributeKind.CommonName, value);
                    }
                    else if (derId.Id == X509Name.Street.Id)
                    {
                        result.Add(X509SubjectAttributeKind.Street, value);
                    }
                    else if (derId.Id == X509Name.SerialNumber.Id)
                    {
                        result.Add(X509SubjectAttributeKind.SerialNumber, value);
                    }
                    else if (derId.Id == X509Name.L.Id)
                    {
                        result.Add(X509SubjectAttributeKind.Locality, value);
                    }
                    else if (derId.Id == X509Name.ST.Id)
                    {
                        result.Add(X509SubjectAttributeKind.State, value);
                    }
                }
            }

            return result;
        }

        /// <summary>
        /// Re-orders a certificate chain from lowest to highest level of trust.
        /// </summary>
        /// <param name="certChain">The certificate chain to re-order.</param>
        /// <returns>
        /// The certificates in the specified chain, ordered from lowest to highest level of trust.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="certChain"/> is null.</exception>
        /// <exception cref="ArgumentException"><paramref name="certChain"/> is empty.</exception>
        /// <exception cref="ArgumentException"><paramref name="certChain"/> contains a null element.</exception>
        /// <exception cref="ArgumentException"><paramref name="certChain"/> is malformed.</exception>
        public static IReadOnlyList<X509Certificate> OrderCertChainFromLowestToHighestLevelOfTrust(
            this IReadOnlyCollection<X509Certificate> certChain)
        {
            if (certChain == null)
            {
                throw new ArgumentNullException(nameof(certChain));
            }

            if (!certChain.Any())
            {
                throw new ArgumentException(Invariant($"'{nameof(certChain)}' is an empty enumerable"));
            }

            if (certChain.Any(_ => _ == null))
            {
                throw new ArgumentException(Invariant($"'{nameof(certChain)}' contains an element that is null"));
            }

            var result = certChain.OrderCertChainFromHighestToLowestLevelOfTrust().Reverse().ToList();
            return result;
        }

        /// <summary>
        /// Re-orders a certificate chain from highest to lowest level of trust.
        /// </summary>
        /// <param name="certChain">The certificate chain to re-order.</param>
        /// <returns>
        /// The certificates in the specified chain, ordered from highest to lowest level of trust.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="certChain"/> is null.</exception>
        /// <exception cref="ArgumentException"><paramref name="certChain"/> is empty.</exception>
        /// <exception cref="ArgumentException"><paramref name="certChain"/> contains a null element.</exception>
        /// <exception cref="ArgumentException"><paramref name="certChain"/> is malformed.</exception>
        [SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = ObcSuppressBecause.CA1502_AvoidExcessiveComplexity_DisagreeWithAssessment)]
        public static IReadOnlyList<X509Certificate> OrderCertChainFromHighestToLowestLevelOfTrust(
            this IReadOnlyCollection<X509Certificate> certChain)
        {
            if (certChain == null)
            {
                throw new ArgumentNullException(nameof(certChain));
            }

            if (!certChain.Any())
            {
                throw new ArgumentException(Invariant($"'{nameof(certChain)}' is an empty enumerable"));
            }

            if (certChain.Any(_ => _ == null))
            {
                throw new ArgumentException(Invariant($"'{nameof(certChain)}' contains an element that is null"));
            }

            certChain = certChain.Distinct().ToList();

            // for every cert, record which other certs verify it
            var parentCertsByChildCert = new Dictionary<X509Certificate, List<X509Certificate>>();
            foreach (var cert in certChain)
            {
                parentCertsByChildCert.Add(cert, new List<X509Certificate>());

                var otherCerts = certChain.Except(new[] { cert }).ToList();
                foreach (var otherCert in otherCerts)
                {
                    try
                    {
                        cert.Verify(otherCert.GetPublicKey());
                        parentCertsByChildCert[cert].Add(otherCert);
                    }

                    // ReSharper disable once EmptyGeneralCatchClause
                    catch (Exception)
                    {
                    }
                }
            }

            // any cert has two parents?
            if (parentCertsByChildCert.Values.Any(_ => _.Count > 1))
            {
                throw new ArgumentException("the cert chain is malformed");
            }

            // should only be one cert with no parent
            if (parentCertsByChildCert.Values.Count(_ => !_.Any()) != 1)
            {
                throw new ArgumentException("the cert chain is malformed");
            }

            // identify and remove the root cert, the remaining certs should have only one parent
            var rootCert = parentCertsByChildCert.Single(_ => !_.Value.Any()).Key;
            parentCertsByChildCert.Remove(rootCert);

            // no two certs should have the same parent
            if (parentCertsByChildCert.SelectMany(_ => _.Value).Distinct().Count() != parentCertsByChildCert.Count)
            {
                throw new ArgumentException("the cert chain is malformed");
            }

            // flip it and index the certs by parent
            var childCertByParentCert = parentCertsByChildCert.ToDictionary(_ => _.Value.Single(), _ => _.Key);
            var result = new List<X509Certificate> { rootCert };
            while (childCertByParentCert.ContainsKey(result.Last()))
            {
                result.Add(childCertByParentCert[result.Last()]);
            }

            return result;
        }

        /// <summary>
        /// Extracts a certificate chain from PKCS#7 CMS payload encoded in PEM.
        /// </summary>
        /// <param name="pemEncodedPkcs7">The payload containing the PKCS#7 CMS data.</param>
        /// <remarks>
        /// The method is expecting a PKCS#7/CMS SignedData structure containing no "content" and zero SignerInfos.
        /// </remarks>
        /// <returns>
        /// The certificate chain contained in the specified payload.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="pemEncodedPkcs7"/> is null.</exception>
        /// <exception cref="ArgumentException"><paramref name="pemEncodedPkcs7"/> is white space.</exception>
        public static IReadOnlyList<X509Certificate> ReadCertChainFromPemEncodedPkcs7CmsString(
            string pemEncodedPkcs7)
        {
            if (pemEncodedPkcs7 == null)
            {
                throw new ArgumentNullException(nameof(pemEncodedPkcs7));
            }

            if (string.IsNullOrWhiteSpace(pemEncodedPkcs7))
            {
                throw new ArgumentException(Invariant($"'{nameof(pemEncodedPkcs7)}' is white space"));
            }

            IReadOnlyList<X509Certificate> result;
            using (var stringReader = new StringReader(pemEncodedPkcs7))
            {
                var pemReader = new PemReader(stringReader);
                var pemObject = pemReader.ReadPemObject();
                var data = new CmsSignedData(pemObject.Content);
                var certStore = data.GetCertificates("COLLECTION");
                result = certStore.GetMatches(null).Cast<X509Certificate>().ToList();
            }

            return result;
        }

        /// <summary>
        /// Reads one or more certs encoded in PEM.
        /// </summary>
        /// <param name="pemEncodedCerts">The PEM encoded certificates.</param>
        /// <returns>
        /// The certificates.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="pemEncodedCerts"/> is null.</exception>
        /// <exception cref="ArgumentException"><paramref name="pemEncodedCerts"/> is white space.</exception>
        public static IReadOnlyList<X509Certificate> ReadCertsFromPemEncodedString(
            string pemEncodedCerts)
        {
            if (pemEncodedCerts == null)
            {
                throw new ArgumentNullException(nameof(pemEncodedCerts));
            }

            if (string.IsNullOrWhiteSpace(pemEncodedCerts))
            {
                throw new ArgumentException(Invariant($"'{nameof(pemEncodedCerts)}' is white space"));
            }

            // remove empty lines - required so that PemReader.ReadObject doesn't return null in-between returning certs
            pemEncodedCerts = Regex.Replace(pemEncodedCerts, @"^\s*$[\r\n]*", string.Empty, RegexOptions.Multiline);

            var result = new List<X509Certificate>();
            using (var stringReader = new StringReader(pemEncodedCerts))
            {
                var pemReader = new PemReader(stringReader);
                var certObject = pemReader.ReadObject();
                while (certObject != null)
                {
                    var cert = certObject as X509Certificate;
                    result.Add(cert);
                    certObject = pemReader.ReadObject();
                }
            }

            return result;
        }

        /// <summary>
        /// Reads a certificate signing request encoded in PEM.
        /// </summary>
        /// <param name="pemEncodedCsr">The PEM encoded certificate signing request.</param>
        /// <returns>
        /// The certificate signing request.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="pemEncodedCsr"/> is null.</exception>
        /// <exception cref="ArgumentException"><paramref name="pemEncodedCsr"/> is white space.</exception>
        public static Pkcs10CertificationRequest ReadCsrFromPemEncodedString(
            string pemEncodedCsr)
        {
            if (pemEncodedCsr == null)
            {
                throw new ArgumentNullException(nameof(pemEncodedCsr));
            }

            if (string.IsNullOrWhiteSpace(pemEncodedCsr))
            {
                throw new ArgumentException(Invariant($"'{nameof(pemEncodedCsr)}' is white space"));
            }

            Pkcs10CertificationRequest result;
            using (var stringReader = new StringReader(pemEncodedCsr))
            {
                var pemReader = new PemReader(stringReader);
                var pemObject = pemReader.ReadPemObject();
                result = new Pkcs10CertificationRequest(pemObject.Content);
            }

            return result;
        }

        /// <summary>
        /// Reads a private key encoded in PEM.
        /// </summary>
        /// <param name="pemEncodedPrivateKey">The PEM encoded private key.</param>
        /// <returns>
        /// The private key.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="pemEncodedPrivateKey"/> is null.</exception>
        /// <exception cref="ArgumentException"><paramref name="pemEncodedPrivateKey"/> is white space.</exception>
        public static AsymmetricKeyParameter ReadPrivateKeyFromPemEncodedString(
            string pemEncodedPrivateKey)
        {
            if (pemEncodedPrivateKey == null)
            {
                throw new ArgumentNullException(nameof(pemEncodedPrivateKey));
            }

            if (string.IsNullOrWhiteSpace(pemEncodedPrivateKey))
            {
                throw new ArgumentException(Invariant($"'{nameof(pemEncodedPrivateKey)}' is white space"));
            }

            AsymmetricKeyParameter result;

            using (var stringReader = new StringReader(pemEncodedPrivateKey))
            {
                var pemReader = new PemReader(stringReader);

                var pemReaderResult = pemReader.ReadObject();

                if (pemReaderResult == null)
                {
                    result = null;
                }
                else if (pemReaderResult is RsaPrivateCrtKeyParameters rsaPrivateCrtKeyParameters)
                {
                    result = rsaPrivateCrtKeyParameters;
                }
                else if (pemReaderResult is AsymmetricCipherKeyPair asymmetricCipherKeyPair)
                {
                    result = asymmetricCipherKeyPair.Private;
                }
                else
                {
                    throw new NotSupportedException("Type of PEM encoded private key not supported: " + pemReaderResult.GetType());
                }
            }

            return result;
        }

        /// <summary>
        /// Creates a certificate signing request.
        /// </summary>
        /// <remarks>
        /// Adapted from: <a href="https://gist.github.com/Venomed/5337717aadfb61b09e58" />.
        /// Adapted from: <a href="http://perfectresolution.com/2011/10/dynamically-creating-a-csr-private-key-in-net/" />.
        /// </remarks>
        /// <param name="asymmetricKeyPair">The asymmetric cipher key pair.</param>
        /// <param name="signatureAlgorithm">The algorithm to use for signing.</param>
        /// <param name="attributesInOrder">
        /// The attributes to use in the subject in the order they should be scanned -
        /// from most general (e.g. country) to most specific.
        /// </param>
        /// <param name="extensions">The x509 extensions to apply.</param>
        /// <returns>
        /// A certificate signing request.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="asymmetricKeyPair"/> is null.</exception>
        /// <exception cref="ArgumentException"><paramref name="signatureAlgorithm"/> is <see cref="SignatureAlgorithm.None"/>.</exception>
        /// <exception cref="ArgumentNullException"><paramref name="attributesInOrder"/> is null.</exception>
        /// <exception cref="ArgumentException"><paramref name="attributesInOrder"/> is empty.</exception>
        /// <exception cref="ArgumentNullException"><paramref name="extensions"/> is null.</exception>
        /// <exception cref="ArgumentException"><paramref name="extensions"/> is empty.</exception>
        [SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling", Justification = "There are many types required to construct a CSR.")]
        private static Pkcs10CertificationRequest CreateCsr(
            this AsymmetricCipherKeyPair asymmetricKeyPair,
            SignatureAlgorithm signatureAlgorithm,
            IReadOnlyList<DerObjectValue> attributesInOrder,
            IReadOnlyDictionary<DerObjectIdentifier, X509Extension> extensions)
        {
            if (asymmetricKeyPair == null)
            {
                throw new ArgumentNullException(nameof(asymmetricKeyPair));
            }

            if (signatureAlgorithm == SignatureAlgorithm.None)
            {
                throw new ArgumentOutOfRangeException(Invariant($"'{nameof(signatureAlgorithm)}' == '{SignatureAlgorithm.None}'"), (Exception)null);
            }

            if (attributesInOrder == null)
            {
                throw new ArgumentNullException(nameof(attributesInOrder));
            }

            if (!attributesInOrder.Any())
            {
                throw new ArgumentException(Invariant($"'{nameof(attributesInOrder)}' is an empty enumerable"));
            }
                
            if (extensions == null)
            {
                throw new ArgumentNullException(nameof(extensions));
            }

            if (!extensions.Any())
            {
                throw new ArgumentException(Invariant($"'{nameof(extensions)}' is an empty enumerable"));
            }

            var signatureFactory = new Asn1SignatureFactory(signatureAlgorithm.ToSignatureAlgorithmString(), asymmetricKeyPair.Private);

            var subject = new X509Name(attributesInOrder.Select(_ => _.Identifier).ToList(), attributesInOrder.Select(_ => _.Value).ToList());

            var extensionsForCsr = extensions.ToDictionary(_ => _.Key, _ => _.Value);

            var result = new Pkcs10CertificationRequest(
                signatureFactory,
                subject,
                asymmetricKeyPair.Public,
                new DerSet(new AttributePkcs(PkcsObjectIdentifiers.Pkcs9AtExtensionRequest, new DerSet(new X509Extensions(extensionsForCsr)))));
            return result;
        }

        private static string ToSignatureAlgorithmString(
            this SignatureAlgorithm signatureAlgorithm)
        {
            switch (signatureAlgorithm)
            {
                case SignatureAlgorithm.Md2WithRsaEncryption:
                    return "MD2WITHRSAENCRYPTION";
                case SignatureAlgorithm.Md5WithRsaEncryption:
                    return "MD5WITHRSAENCRYPTION";
                case SignatureAlgorithm.Sha1WithRsaEncryption:
                    return "SHA1WITHRSAENCRYPTION";
                case SignatureAlgorithm.Sha224WithRsaEncryption:
                    return "SHA224WITHRSAENCRYPTION";
                case SignatureAlgorithm.Sha256WithRsaEncryption:
                    return "SHA256WITHRSAENCRYPTION";
                case SignatureAlgorithm.Sha384WithRsaEncryption:
                    return "SHA384WITHRSAENCRYPTION";
                case SignatureAlgorithm.Sha512WithRsaEncryption:
                    return "SHA512WITHRSAENCRYPTION";
                case SignatureAlgorithm.IdRsassaPss:
                    return "SHA1WITHRSAANDMGF1";
                case SignatureAlgorithm.RsaSignatureWithRipeMd160:
                    return "RIPEMD160WITHRSAENCRYPTION";
                case SignatureAlgorithm.RsaSignatureWithRipeMd128:
                    return "RIPEMD128WITHRSAENCRYPTION";
                case SignatureAlgorithm.RsaSignatureWithRipeMd256:
                    return "RIPEMD256WITHRSAENCRYPTION";
                case SignatureAlgorithm.IdDsaWithSha1:
                    return "SHA1WITHDSA";
                case SignatureAlgorithm.DsaWithSha224:
                    return "SHA224WITHDSA";
                case SignatureAlgorithm.DsaWithSha256:
                    return "SHA256WITHDSA";
                case SignatureAlgorithm.DsaWithSha384:
                    return "SHA384WITHDSA";
                case SignatureAlgorithm.DsaWithSha512:
                    return "SHA512WITHDSA";
                case SignatureAlgorithm.EcDsaWithSha1:
                    return "SHA1WITHECDSA";
                case SignatureAlgorithm.EcDsaWithSha224:
                    return "SHA224WITHECDSA";
                case SignatureAlgorithm.EcDsaWithSha256:
                    return "SHA256WITHECDSA";
                case SignatureAlgorithm.EcDsaWithSha384:
                    return "SHA384WITHECDSA";
                case SignatureAlgorithm.EcDsaWithSha512:
                    return "SHA512WITHECDSA";
                case SignatureAlgorithm.GostR3411x94WithGostR3410x94:
                    return "GOST3411WITHGOST3410";
                case SignatureAlgorithm.GostR3411x94WithGostR3410x2001:
                    return "GOST3411WITHECGOST3410";
                default:
                    throw new NotSupportedException("this algorithm is not supported: " + signatureAlgorithm);
            }
        }

        private class DerObjectValue
        {
            public DerObjectValue(
                DerObjectIdentifier identifier,
                string value)
            {
                this.Identifier = identifier;
                this.Value = value;
            }

            public DerObjectIdentifier Identifier { get; }

            public string Value { get; }
        }
    }
}
